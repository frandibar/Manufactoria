#!/usr/bin/env racket
#lang racket

;; UNFINISHED
;; The idea is to get the hardware from code generated by hand.
;; It would be nice if one could program the solution, and obtain the hardware.
;; As a first step, the solution should be written using the same primitives that build-machine uses.

;; These are the primitives
(define (blue? color) (eq? color 'b))
(define (red? color) (eq? color 'r))
(define (green? color) (eq? color 'g))
(define (yellow? color) (eq? color 'y))
(define (next tape) (if (null? tape) null (car tape)))
(define (tail tape) (if (null? tape) null (cdr tape)))
(define (accept tape) (list 'accepted tape))
(define (reject tape) (list 'rejected tape))

(define (writer tape where-next color) (where-next (append tape (list color))))

(define (blue-red tape if-blue if-red if-none)
  (let ((color (next tape)) (tape-tail (tail tape)))
    (cond
     ((blue? color) (if-blue tape-tail))
     ((red? color) (if-red tape-tail))
     (else (if-none tape)))))

(define (yellow-green tape if-yellow if-green if-none)
  (let ((color (next tape)) (tape-tail (tail tape)))
    (cond
     ((green? color) (if-green tape-tail))
     ((yellow? color) (if-yellow tape-tail))
     (else (if-none tape)))))

;; The idea is to solve the problem with high levels of abstraction
;; (without using any special language/library function calls),
;; and then decompose it until the only methods used are the primitives listed above.
;; Once we reach that point, each primitive is mapped to a hardware component and placed at a certain position in the grid.

;; for example...


(define (test-machine machine input expected-output)
  (let ((output ((eval machine (make-base-namespace)) input)))
    (display (list input (if (equal? output expected-output) 
                             (list "PASS: returned " output) 
                             (list "FAIL: returned " output " instead of " expected-output))))
    (newline)))

;; Androids!
;; ACCEPT: some number of blue, then the same number of red.
(define (androids-v1 tape)
  (define (blue-rec tape n)
    (if (and (null? tape) (= n 0))
        (reject tape)
        (blue-red tape 
                  (lambda (t) (blue-rec t (+ n 1)))
                  (lambda (t) (red-rec t (- n 1)))
                  reject)))
  (define (red-rec tape n)
    (cond
     ((< n 0) (reject tape))
     ((null? tape) (if (= n 0) (accept tape) (reject tape)))
     (else
      (blue-red tape 
                reject
                (lambda (t) (red-rec t (- n 1)))
                reject))))
  (if (null? tape) 
      (accept tape)
      (blue-rec tape 0)))

(define (androids tape)
  (define (read-1st-br tape)
    (blue-red tape read-2nd-after-blue read-2nd-after-red check-no-yg))
  (define (read-2nd-after-blue tape)
    (blue-red tape write-green-and-loop read-red reject))
  (define (read-2nd-after-red tape)
    (blue-red tape reject write-yellow-and-read-red-bis reject))
  (define (check-no-yg tape)
    (yellow-green tape reject reject accept))
  (define (read-yg-and-loop tape)
    (yellow-green tape write-red-and-loop write-blue-and-loop read-1st-br))
  (define (write-green-and-loop tape)
    (writer tape read-1st-br 'g))
  (define (read-red tape)
    (blue-red tape reject read-2nd-red read-yg-and-loop))
  (define (read-2nd-red tape)
    (blue-red tape reject write-yellow-and-read-red reject))
  (define (write-yellow-and-read-red tape)
    (writer tape read-red 'y))
  (define (write-yellow-and-read-red-bis tape)
    (writer tape read-2nd-red-bis 'y))
  (define (read-2nd-red-bis tape)
    (blue-red tape reject read-2nd-after-red read-yg-and-loop-bis))
  (define (read-yg-and-loop-bis tape)
    (yellow-green tape write-red-and-loop write-blue-and-loop read-1st-br))
  (define (write-blue-and-loop tape)
    (writer tape read-yg-and-loop 'b))
  (define (write-red-and-loop tape)
    (writer tape read-yg-and-loop 'r))
  (read-1st-br tape))
    

(define androids-test-input '( (() (accepted ()))
                               ((b) (rejected ()))
                               ((r) (rejected ()))
                               ((b r) (accepted ()))
                               ((r b) (rejected ()))
                               ((b b) (rejected ()))
                               ((b b r) (rejected (g)))
                               ((b r b) (rejected ()))
                               ((b b r r) (accepted ()))
                               ((b b b r r r) (accepted ()))
                               ((b b b r b r r) (rejected (r r g)))
                               ((b b b r r r b) (rejected (g y)))
                               ((b b b r r) (rejected (g)))
                               ((b b b r r r r) (rejected (g y)))
                               ))
      
(display "androids test:\n")
(map (lambda (x) (test-machine androids (first x) (second x))) androids-test-input)

(define rocket-planes
  (lambda (tape)
    (define (write-end-flag tape)
      (writer tape read-first 'g))
    (define (read-first tape)
      (blue-red tape rewrite-blue-prefix found-red drop-end-flag))
    (define (rewrite-blue-prefix tape)
      (writer tape read-first 'b))
    (define (drop-end-flag tape)
      (yellow-green tape null accept null))
    (define (found-red tape)
      (blue-red tape blue-after-red rewrite-continuous-red rewrite-red-and-finish))
    (define (rewrite-continuous-red tape)
      (writer tape found-red 'r))
    (define (rewrite-red-and-finish tape)
      (writer tape drop-end-flag-and-finish 'r))
    (define (drop-end-flag-and-finish tape)
      (yellow-green tape null accept null))
    (define (blue-after-red tape)
      (writer tape read-until-end 'b))
    (define (read-until-end tape)
      (blue-red tape rewrite-blue rewrite-red write-red-and-loop))
    (define (rewrite-blue tape)
      (writer tape read-until-end 'b))
    (define (rewrite-red tape)
      (writer tape read-until-end 'r))
    (define (write-red-and-loop tape)
      (writer tape drop-end-flag-and-loop 'r))
    (define (drop-end-flag-and-loop tape)
      (yellow-green tape null write-end-flag null))
    (write-end-flag tape)))

(define rocket-planes-test-input '( (() (accepted ()))
                                    ((r) (accepted (r)))
                                    ((r r) (accepted (r r)))
                                    ((r b) (accepted (b r)))
                                    ((b) (accepted (b)))
                                    ((b r) (accepted (b r)))
                                    ((b b) (accepted (b b)))
                                    ((r b b) (accepted (b b r)))
                                    ((r b b r r r b) (accepted (b b b r r r r)))
                                    ))

;; (display "rocket-planes test:\n")
;; (map (lambda (x) (test-machine rocket-planes (first x) (second x))) rocket-planes-test-input)

(define robomecha
  (lambda (tape)
    (define (write-end-flag tape)
      (writer tape read-first 'g))
    (define (read-first tape)
      (blue-red tape read-2nd-after-blue read-2nd-after-red accept))
    (define (last-is-blue tape)
      (writer tape blue-to-front 'g))
    (define (last-is-red tape)
      (writer tape red-to-front 'g))
    (define (blue-to-front tape)
      (writer tape rewrite-until-end 'b))
    (define (red-to-front tape)
      (writer tape rewrite-until-end 'r)) 
    (define (rewrite-until-end tape)
      (blue-red tape rewrite-blue rewrite-red accept))
    (define (rewrite-blue tape)
      (writer tape rewrite-until-end 'b))
    (define (rewrite-red tape)
      (writer tape rewrite-until-end 'r))
    (define (read-2nd-after-blue tape)
      (blue-red tape 
                write-blue-and-read-after-blue 
                write-blue-and-read-after-red 
                last-is-blue))
    (define (read-2nd-after-red tape)
      (blue-red tape 
                write-red-and-read-after-blue 
                write-red-and-read-after-red 
                last-is-red))
    (define (write-blue-and-read-after-blue tape)
      (writer tape read-2nd-after-blue 'b))
    (define (write-blue-and-read-after-red tape)
      (writer tape read-2nd-after-red 'b))
    (define (write-red-and-read-after-blue tape)
      (writer tape read-2nd-after-blue 'r))
    (define (write-red-and-read-after-red tape)
      (writer tape read-2nd-after-red 'r))
    (write-end-flag tape)))


(define robomecha-test-input '( (() (accepted ()))
                                ((r) (accepted (r)))
                                ((r r) (accepted (r r)))
                                ((r b) (accepted (b r)))
                                ((b) (accepted (b)))
                                ((b r) (accepted (r b)))
                                ((b b) (accepted (b b)))
                                ((r b b) (accepted (b r b)))
                                ((r b b r r r b) (accepted (b r b b r r r)))
                                ))

;; (display "robomecha test:\n")
;; (map (lambda (x) (test-machine robomecha (first x) (second x))) robomecha-test-input)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; (require (only-in "dot.rkt"
;;                   graph->png))

;; ;; TODO I can't find a way to process the procedure as a list!
;; (define (machine-to-graph machine)
;;   (define (nodes machine)
;;     (map car (list machine)))
;;   ;; (define (edges machine)
;;   ;;   ())
;;   (display (nodes machine))
;;   ;; (display (edges machine))
;;   ;; (graph->png (nodes robomecha) (edges robomecha) true))
;; )

;; (machine-to-graph robomecha)