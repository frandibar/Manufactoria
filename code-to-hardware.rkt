#!/usr/bin/env racket
#lang racket

;; UNFINISHED
;; The idea is to get the hardware from code generated by hand.
;; It would be nice if one could program the solution, and obtain the hardware.
;; As a first step, the solution should be written using the same primitives that build-machine uses.

;; These are the primitives
(define (blue? color) (eq? color 'b))
(define (red? color) (eq? color 'r))
(define (green? color) (eq? color 'g))
(define (yellow? color) (eq? color 'y))
(define (next tape) (if (null? tape) null (car tape)))
(define (tail tape) (if (null? tape) null (cdr tape)))
(define (accept tape) (list 'accepted tape))
(define (reject tape) (list 'rejected tape))

(define (writer tape where-next color) (where-next (append tape (list color))))

(define (blue-red tape if-blue if-red if-none)
  (let ((color (next tape)) (tape-tail (tail tape)))
    (cond
     ((blue? color) (if-blue tape-tail))
     ((red? color) (if-red tape-tail))
     (else (if-none tape-tail)))))

(define (yellow-green tape if-yellow if-green if-none)
  (let ((color (next tape)) (tape-tail (tail tape)))
    (cond
     ((green? color) (if-green tape-tail))
     ((yellow? color) (if-yellow tape-tail))
     (else (if-none tape)))))

;; The idea is to solve the problem with high levels of abstraction
;; (without using any special language/library function calls),
;; and then decompose it until the only methods used are the primitives listed above.
;; Once we reach that point, each primitive is mapped to a hardware component and placed at a certain position in the grid.

;; for example...
;; Androids!
;; ACCEPT: some number of blue, then the same number of red.
;; TODO: FINISH!
(define (androids tape)
  (define (blue-rec tape n)
    (if (and (null? tape) (= n 0))
        (reject tape)
        (blue-red tape 
                  (lambda (t) (blue-rec t (+ n 1)))
                  (lambda (t) (red-rec t (- n 1)))
                  reject)))
  (define (red-rec tape n)
    (cond
     ((< n 0) (reject tape))
     ((null? tape) (if (= n 0) (accept tape) (reject tape)))
     (else
      (blue-red tape 
                reject
                (lambda (t) (red-rec t (- n 1)))
                reject))))
  (if (null? tape) 
      (accept tape)
      (blue-rec tape 0)))


(define (test-machine machine input expected-output)
  (let ((output (machine input)))
    (display (list input (if (equal? output expected-output) 
                             (list "PASS: returned " output) 
                             (list "FAIL: returned " output " instead of " expected-output))))
    (newline)))

(define androids-test-input '( (() (accepted ()))
                               ((b) (rejected ()))
                               ((r) (rejected ()))
                               ((b r) (accepted ()))
                               ((r b) (rejected (b)))
                               ((b b r) (rejected ()))
                               ((b r b) (rejected ()))
                               ((b b r r) (accepted ()))
                               ))

;; (display "androids test:\n")
;; (map (lambda (x) (test-machine androids (first x) (second x))) androids-test-input)

;; TODO: FINISH!
;; TODO: it would be interesting to have a code-to-dot, that takes the code for a machine and produces a dot representation.
;;       Current manufactoria-to-dot intends to do a representation of a hardware string.
(define (robomecha tape)
  (define (TODO tape)
    (display (list "undefined yet!" tape))
    (newline))
  (define (write-end-flag tape)
    (writer tape read-butlast 'g))
  (define (read-butlast tape)
    (blue-red tape rewrite-blue rewrite-red accept))
  (define (rewrite-red tape)
    (writer tape read-last-after-red 'r))
  (define (rewrite-blue tape)
    (writer tape read-last-after-blue 'b))
  (define (read-last-after-red tape)
    (blue-red tape TODO TODO accept))
  (define (read-last-after-blue tape)
    (blue-red tape TODO TODO TODO))
  (write-end-flag tape))

(define robomecha-test-input '( (() (accepted ()))
                                ((r) (accepted (r)))
                                ((r r) (accepted (r r)))
                                ((r b) (accepted (b r)))
                                ))

(display "robomecha test:\n")
(map (lambda (x) (test-machine robomecha (first x) (second x))) robomecha-test-input)
